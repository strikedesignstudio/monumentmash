<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Monument Mashup</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #loading {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Monument Mashup...</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>


<script>
  // --- SCENE SETUP ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
  camera.position.set(0, 0, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // --- LIGHTS ---
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  hemiLight.position.set(0, 2, 0);
  scene.add(hemiLight);

  // --- GLOBAL VARIABLES ---
  const clickableObjects = [];
  const hoverableObjects = []; // only meshes that should respond to hover
  let INTERSECTED;
  const loadingText = document.getElementById('loading');

  // --- AUDIO SETUP ---
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const audioLoader = new THREE.AudioLoader();
  let audioBufferShared = null;
  let currentSource = null;

  const audioSegments = {
    "Hilmi": 6,
    "Anon": 66,
    "Henry": 85.2,
    "Sabir": 120.6,
    "Shemi": 137.4,
    "Hannah": 187.2,
    "Evodie": 240,
    "Marvin": 270,
    "Jessica": 327,
    "Rachid": 444.6,
    "Jermaine": 557.4,
    "Dominic": 614.4
  };

  const hoverColorMap = {
    "Hilmi": 0xff0000,
    "Anon": 0x00ff00,
    "Henry": 0x0000ff,
    "Sabir": 0xffff00,
    "Shemi": 0xff00ff,
    "Hannah": 0x00ffff,
    "Evodie": 0xff8800,
    "Marvin": 0x88ff00,
    "Jessica": 0x0088ff,
    "Rachid": 0x8800ff,
    "Jermaine": 0xff0088,
    "Dominic": 0x00ff88
  };

  // --- LOAD AUDIO ---
  audioLoader.load('audio/monmashcomp.mp3', function(buffer) {
    audioBufferShared = buffer;
  });

  // --- LOAD GLTF ---
  const loader = new THREE.GLTFLoader();
  loader.load(
    'model/modelfull2.gltf',
    function (gltf) {
      const model = gltf.scene;

      model.scale.set(0.027, 0.027, 0.027);
      model.position.y -= 2.5;
      scene.add(model);

      model.traverse(function (child) {
        if (child.isMesh) {
          clickableObjects.push(child);
          child.material.transparent = true;
           console.log(child.name);

          // Only targeted meshes respond to hover
          if (Object.keys(hoverColorMap).includes(child.name)) {
            hoverableObjects.push(child);
          }
        }
      });

      // --- REMOVE MESH001 IF NEEDED ---
      const meshToRemove = model.getObjectByName('Mesh003');
      if (meshToRemove) {
        scene.remove(meshToRemove);
        const index = clickableObjects.indexOf(meshToRemove);
        if (index > -1) clickableObjects.splice(index, 1);
        meshToRemove.geometry.dispose();
        if (meshToRemove.material.map) meshToRemove.material.map.dispose();
        meshToRemove.material.dispose();
      }

      loadingText.remove();
    },
    function (xhr) {
      if (xhr.total) {
        loadingText.innerText = `Loading... ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`;
      }
    },
    function (error) {
      console.error('GLTF load error:', error);
    }
  );

  // --- RAYCASTING AND AUDIO PLAYBACK ---
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function playFrom(startTime) {
    if (!audioBufferShared) return;
    if (currentSource) currentSource.stop();

    const audioCtx = listener.context;
    const source = audioCtx.createBufferSource();
    source.buffer = audioBufferShared;
    source.connect(listener.getInput());
    source.start(0, startTime);

    currentSource = source;
  }

  function onClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(clickableObjects, true);
    if (intersects.length > 0) {
      const clicked = intersects[0].object;

      // Optional visual feedback
      if (clicked.material && clicked.material.opacity !== undefined) {
        clicked.material.opacity = 0.6;
        setTimeout(() => clicked.material.opacity = 1, 300);
      }

      const segmentStart = audioSegments[clicked.name];
      if (segmentStart !== undefined) playFrom(segmentStart);
    }
  }

  function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(hoverableObjects, true); // only hoverable meshes

    if (intersects.length > 0) {
      const hovered = intersects[0].object;

      if (INTERSECTED !== hovered) {
        if (INTERSECTED) INTERSECTED.targetColor = INTERSECTED.originalColor;

        INTERSECTED = hovered;
        if (!INTERSECTED.originalColor) INTERSECTED.originalColor = INTERSECTED.material.color.clone();

        const colorHex = hoverColorMap[INTERSECTED.name] || 0xffff00;
        INTERSECTED.targetColor = new THREE.Color(colorHex);
      }
    } else {
      if (INTERSECTED) INTERSECTED.targetColor = INTERSECTED.originalColor;
      INTERSECTED = null;
    }
  }

  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('click', onClick);

  // --- RESIZE HANDLER ---
  window.addEventListener('resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- ANIMATE ---
  function animate() {
    requestAnimationFrame(animate);
    controls.update();

    // Smooth hover color transitions
    hoverableObjects.forEach(obj => {
      if (obj.material && obj.material.color && obj.targetColor) {
        obj.material.color.lerp(obj.targetColor, 0.1);
      }
    });

    renderer.render(scene, camera);
  }
  animate();
</script>

</body>
</html>

